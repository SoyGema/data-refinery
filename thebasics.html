

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The Basics &mdash; Data Refinery 0.1.52 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="Data Refinery 0.1.52 documentation" href="index.html"/>
        <link rel="next" title="Tuple DSL documentation" href="dsl.html"/>
        <link rel="prev" title="Instalación" href="installation.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Data Refinery
          

          
          </a>

          
            
            
              <div class="version">
                0.1.52
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introducción</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Instalación</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">The Basics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#operaciones-por-campo">Operaciones por campo</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#una-funcion-que-pueda-fallar">Una función que pueda fallar</a></li>
<li class="toctree-l3"><a class="reference internal" href="#listado-de-funciones">Listado de funciones</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#reforzando-un-tipo">Reforzando un tipo</a></li>
<li class="toctree-l4"><a class="reference internal" href="#normalizacion-min-max">Normalización min max</a></li>
<li class="toctree-l4"><a class="reference internal" href="#puntuacion-estandar">Puntuación estandar</a></li>
<li class="toctree-l4"><a class="reference internal" href="#agrupando-por-valor">Agrupando por valor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#categorizacion-lineal">Categorización lineal</a></li>
<li class="toctree-l4"><a class="reference internal" href="#categorizacion-columnar">Categorización columnar</a></li>
<li class="toctree-l4"><a class="reference internal" href="#prefijo-de-columna">Prefijo de columna</a></li>
<li class="toctree-l4"><a class="reference internal" href="#deconstruccion-de-campos">Deconstrucción de campos</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sustituyendo-valores">Sustituyendo valores</a></li>
<li class="toctree-l4"><a class="reference internal" href="#procesando-fechas-y-horas">Procesando fechas y horas</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explosion-temporal">Explosión temporal</a></li>
<li class="toctree-l4"><a class="reference internal" href="#quitando-columnas">Quitando columnas</a></li>
<li class="toctree-l4"><a class="reference internal" href="#buscando-el-valor">Buscando el valor</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#combinando-operaciones-de-campo">Combinando operaciones de campo</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#normalizacion-numerica">Normalización numérica</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fecha-completa">Fecha completa</a></li>
<li class="toctree-l4"><a class="reference internal" href="#one-hot-vector-del-dia">One hot vector del día</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#operaciones-de-evento">Operaciones de evento</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">Listado de funciones</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#keep-mantener-campos">Keep - Mantener campos</a></li>
<li class="toctree-l4"><a class="reference internal" href="#substitution-substituir-campos">Substitution - Substituir campos</a></li>
<li class="toctree-l4"><a class="reference internal" href="#append-anadir-nuevos-campos-a-partir-de-uno">Append - Añadir nuevos campos a partir de uno</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fusion-combinar-campos">Fusion - Combinar campos</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fusion-append-varios-entran-varios-salen">Fusion_append - Varios entran, varios salen</a></li>
<li class="toctree-l4"><a class="reference internal" href="#filter-tuple-solo-filas-vip">Filter_tuple - Sólo filas vip</a></li>
<li class="toctree-l4"><a class="reference internal" href="#alternative-plan-b">Alternative - Plan B</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fallo-con-estilo">Fallo con estilo</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#combinando-operaciones-de-evento">Combinando operaciones de evento</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#un-bosque-de-posibilidades">Un bosque de posibilidades</a></li>
<li class="toctree-l4"><a class="reference internal" href="#then-empujando-transformaciones-al-inicio">Then - Empujando transformaciones al inicio</a></li>
<li class="toctree-l4"><a class="reference internal" href="#peek-cata-de-datos">Peek - Cata de datos</a></li>
<li class="toctree-l4"><a class="reference internal" href="#secuencialidad">Secuencialidad</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#dsl">DSL</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#repaso-con-ejercicios">Repaso con ejercicios</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="dsl.html">Tuple DSL documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">Módulos</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glosario</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Data Refinery</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>The Basics</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/thebasics.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-basics">
<h1>The Basics<a class="headerlink" href="#the-basics" title="Permalink to this headline">¶</a></h1>
<div class="section" id="operaciones-por-campo">
<h2>Operaciones por campo<a class="headerlink" href="#operaciones-por-campo" title="Permalink to this headline">¶</a></h2>
<p><strong>TODO: explicar cómo construimos la narrativa desde el campo a un proceso completo.</strong></p>
<p>El campo como raíz del cambioUn ETL se compone de un conjunto de operaciones sobre una fila. Las filas están compuestas por conjuntos de campos. De forma que la operación mínima que podemos llevar a cabo pasa en un campo.</p>
<p>Supongamos una función no hace nada aplicada al campo V:![None function.jpg](https://lh3.googleusercontent.com/KZ1MTv9z3QagVn_Gn5D4Jj7ZfPgcugdL1aIN-Mv63YY_hupDKqjqur4ZAOL3jXiEfXSoKsj5QuANVyrm14HHrTuAK2oJGIQcxUPzQGMT_WXlnTEyuqqSTss1cJSxoaBRqQu-XL96)Como el proceso está compuesto por operaciones sobre los campos si aplicamos esta función, a una fila que solo tiene el campo V, no obtendremos ninguna salida.</p>
<p>De esta forma llegamos hasta la primera función necesaria, mantener el valor de un campo. Para mantener el valor necesitamos un función que devuelva lo que reciba, típicamente esta función es conocida como identidad:![función identidad.jpg](<a class="reference external" href="https://lh3.googleusercontent.com/wCpoosG-B8hIWrrjHDiG8nZV2riGoIamZrQHwMa2WrOa1DFcKJJgqjJQYq6JNEoEat2F3iBwAoEuIlJjG1RjjBSa4v1IfxRDXEJ2GYLF6oZRwYnmcOmxtJboQXdrBDNe3s3OGPeC">https://lh3.googleusercontent.com/wCpoosG-B8hIWrrjHDiG8nZV2riGoIamZrQHwMa2WrOa1DFcKJJgqjJQYq6JNEoEat2F3iBwAoEuIlJjG1RjjBSa4v1IfxRDXEJ2GYLF6oZRwYnmcOmxtJboQXdrBDNe3s3OGPeC</a>)</p>
<div class="section" id="una-funcion-que-pueda-fallar">
<h3>Una función que pueda fallar<a class="headerlink" href="#una-funcion-que-pueda-fallar" title="Permalink to this headline">¶</a></h3>
<p>Dentro de las situaciones que nos encontramos durante una transformación de datos debemos enfrentarnos a los errores. Un problema típico de trabajar con datos, sobretodo cuando no pertenecen a una fuente de datos estructurados, es que alguno de los campos que esperamos no esté ahí. En el caso de que no podamos llevar a cabo una transformación, ya sea por cuestiones internas al campo o por errores externos al proceso, debemos informar de la forma más precisa posible y sin detener el proceso. La información de porque no se ha podido procesar un campo debe agregarse a los fallos que puedan tener otros campos, es decir, que no debemos detener el procesamiento de la fila por un campo. De esta forma el científico de datos puede tener una lista completa con todas las cosas a las que debe enfrentarse. De forma similar debemos seguir procesando el dataset aunque una fila no haya podido ser procesada. En este caso no debemos parar de procesar debido a que en producción es común ver datos para los que el modelo no está preparado, en este caso la fila debe ser descartada junto con los motivos de porque esto es así; de esta forma podremos adaptar el ETL a estos cambios en el próximo entrenamiento.</p>
<p>Para solucionar este problema, lo que hacemos es que las funciones para transformar un campo devuelven el posible valor y también el posible error. Esto nos lleva a tres posibles escenarios:</p>
<ul class="simple">
<li>La función devuelve un valor y ningún error</li>
<li>La función devuelve un error, y provoca que nos de lo mismo el valor.</li>
<li>La función no falla, pero tampoco de un valor.</li>
</ul>
<p>En el primer caso podremos usar el valor modificado.
En el segundo caso nos da lo mismo el valor, ya que hay un error que no nos permite seguir.
En el tercer caso depende de la operación que estemos haciendo, descartaremos el campo o fallaremos al no tener valor.</p>
</div>
<div class="section" id="listado-de-funciones">
<h3>Listado de funciones<a class="headerlink" href="#listado-de-funciones" title="Permalink to this headline">¶</a></h3>
<p>El ETL suele pelearse con problemas recurrentes de formato de los datos. Transformar tipos, el cambiar valores si cumplen cierta condición, descomponer datos en sus integrantes… Por eso la librería tiene ya algunas funciones muy comunes ya definidas. También podemos crear nuestras propias funciones, si las existentes no cumplen los requisitos. Y para dar soporte a casos más complejos podemos “encadenar” varias funciones más sencillas, permitiendo un uso atómico por pasos pequeños y posibilitando el cambiar fácilmente la funcionalidad intercalando funciones muy sencillas en un proceso. Una gran mayoría de las funciones de ETL ya definidas necesitan unos parámetros de contexto y con estos construirán y devolverán una función que nos permita llevar a cabo la transformación de campo sin estar pasando un número variable de argumentos. Lo que al fin y al cabo permite la composición sencilla, al compartir todas las funciones la misma entrada y salida en todos los pasos.</p>
<div class="section" id="reforzando-un-tipo">
<h4>Reforzando un tipo<a class="headerlink" href="#reforzando-un-tipo" title="Permalink to this headline">¶</a></h4>
<p>En ocasiones la fuente de datos no contiene información de tipo, o esta no es correcta, y nos llegan números como textos, o similar. Esta función necesita como contexto la función que permite el cambio del tipo, si esta función da algún error supondrá que no puede llevar a cabo la transformación y usará el mensaje de error de la excepción como resultado de error.</p>
<p>Por ejemplo, si quiero cambiar el tipo de un dato a int puedo usar el siguiente código:</p>
</div>
<div class="section" id="normalizacion-min-max">
<h4>Normalización min max<a class="headerlink" href="#normalizacion-min-max" title="Permalink to this headline">¶</a></h4>
<p>Esta es una operación típica en machine learning. Consiste en interpolar entre 0 y 1 un valor, considerando que el 0 es representado por el valor min y el 1 es representado por el valor max. Esta función necesita el mínimo y el máximo como contexto para su creación. Un ejemplo de uso podría ser:</p>
</div>
<div class="section" id="puntuacion-estandar">
<h4>Puntuación estandar<a class="headerlink" href="#puntuacion-estandar" title="Permalink to this headline">¶</a></h4>
<p>Esta operación representa lo lejos que está un dato de la estadística representativa de una columna completa. Para usarlo necesitamos pasarle como contexto la media y la desviación típica de los valores de la columna. Un ejemplo de uso sería:</p>
</div>
<div class="section" id="agrupando-por-valor">
<h4>Agrupando por valor<a class="headerlink" href="#agrupando-por-valor" title="Permalink to this headline">¶</a></h4>
<p>Esta función nos ayuda cuando queremos convertir un valor lineal numérico en uno categórico. Un caso común de uso es agrupar usuarios por edad. Requiere como contexto el paso de al menos un valor, esto generará dos grupos uno desde menos infinito al valor y del valor hasta infinito.</p>
<p>Continuando con el ejmplo de edad, si queremos distinguir entre niños, adultos y jubilados podríamos pasar como valores 18 y 70. De esta forma la agrupación generará los siguientes grupos:</p>
<ol class="arabic simple">
<li>Entre menos infinito y 18</li>
<li>Entre 18 y 70</li>
<li>Entre 70 e infinito</li>
</ol>
<p>En código podríamos ver estas situaciones así:</p>
</div>
<div class="section" id="categorizacion-lineal">
<h4>Categorización lineal<a class="headerlink" href="#categorizacion-lineal" title="Permalink to this headline">¶</a></h4>
<p>Esta operación de campo cambia los datos categóricos, como textos, en un número. Para ellos debemos pasarle las categorías existentes siempre con los elementos en las mismas posiciones (añadiendo siempre al final los nuevos valores).
Esto se debe a que asignará el valor numérico del orden de la lista, y necesitamos que sea coherente entre ejecuciones.</p>
<p>Como ejemplo podemos categorizar de nuevo la edad, pero esta vez nos llega como texto en lugar de como número.</p>
</div>
<div class="section" id="categorizacion-columnar">
<h4>Categorización columnar<a class="headerlink" href="#categorizacion-columnar" title="Permalink to this headline">¶</a></h4>
<p>Funciona como la categorización lineal pero genera una columna con cada valor de la categoría, por defecto tendrá valor de 0, y en la categoría encontrada en el campo tendrá 1. También es conocido como <em>one hot vector</em>.</p>
<p>Continuando con el ejemplo de la edad.</p>
<p>Esta operación añade campos, por lo que suele usarse con una operación de evento de tipo [append](##Cange it).</p>
</div>
<div class="section" id="prefijo-de-columna">
<h4>Prefijo de columna<a class="headerlink" href="#prefijo-de-columna" title="Permalink to this headline">¶</a></h4>
<p>En casos en los que una función genera varios campos es posible que estas coincidan en nombre con otros campos. Por eso podemos usar esta función que añadirá un prefijo al nombre de la columna.</p>
</div>
<div class="section" id="deconstruccion-de-campos">
<h4>Deconstrucción de campos<a class="headerlink" href="#deconstruccion-de-campos" title="Permalink to this headline">¶</a></h4>
<p>Es común encontrar datos anidados, la función explode aplana esta anidación, incluso si esta está formada por una lista de objetos.
En el caso de que haya un solo sub objeto no se añadirá más que el prefijo del nombre de campo original. Pero si hay una lista con varios elementos entonces al nombre del campos se le añadirá, además del prefijo, un sufijo munérico empezando en 1 para la segunda posición; esto es asi para evitar cambiar el nombre de los campos de la primera posición en el caso de recibir un elemento inesperado.</p>
<p>Por ejemplo, si queremos explotar el campo nombre la llamada podría ser asi:</p>
</div>
<div class="section" id="sustituyendo-valores">
<h4>Sustituyendo valores<a class="headerlink" href="#sustituyendo-valores" title="Permalink to this headline">¶</a></h4>
<p>Cuando se estudian los datos en raras ocasiones una columna tiene todos los valores correctamente rellenos. Es muy útil el sustituir un valor cuando este cumple una condición en concreto, pero para añadir flexibilidad usaremos dos funciones, una que debe devolver true o false, y otra función que generará un nuevo valor si la primera función devuelve true; ambas funciones recibiran el valor del campo.</p>
<p>Por ejemplo, si queremos sustituir por cero todos los valores negativos de un campo:</p>
</div>
<div class="section" id="procesando-fechas-y-horas">
<h4>Procesando fechas y horas<a class="headerlink" href="#procesando-fechas-y-horas" title="Permalink to this headline">¶</a></h4>
<p>Las fechas son siempre una fuente de problemas, la variedad de formatos puede ser abrumadora. Para ellos tenemos una función de intenta parsear varios formatos diferentes, y si no lo consigue informa del error para que se añada un formato nuevo.</p>
<p>Los formatos esperados deben ser formatos de fecha estandar de Python.</p>
<p>Hay una función similar solo para formatear horas, minutos y segundos.</p>
</div>
<div class="section" id="explosion-temporal">
<h4>Explosión temporal<a class="headerlink" href="#explosion-temporal" title="Permalink to this headline">¶</a></h4>
<p>Tanto para fechas, como para tiempo, es posible que queramos tener los integrantes del valor como números simples en diferentes campos. Como entrada espera siempre un valor de tipo datetime.</p>
<p>Si hay varias fechas en tu evento considera usar la función [add_prefix](###Prefijo de columna). SI no necesitas todos los campos de la fecha considera usar [remove column](###Quitando columnas). Esta función se usa típicamente en conjunción con un date_parser.</p>
</div>
<div class="section" id="quitando-columnas">
<h4>Quitando columnas<a class="headerlink" href="#quitando-columnas" title="Permalink to this headline">¶</a></h4>
<p>Este método es habitualmente una fuente de confusión. Su uso en solitario no tiene sentido debido a que no puede afectar a todo el evento. Está diseñado solo para ser usado en conjunto con otras funciones de campo que generan varios campos.</p>
<p>En el caso de que quieras eliminar una columna, simplemente no operes sobre ella, la función ETL solo pondrá en el output los campos con los que operes.</p>
<p>Si este es el primer caso de composición que ves considera revisar primero la [documentación](##Combinando operaciones de campo) a este respecto.</p>
</div>
<div class="section" id="buscando-el-valor">
<h4>Buscando el valor<a class="headerlink" href="#buscando-el-valor" title="Permalink to this headline">¶</a></h4>
<p>Hay veces que muchos cambios en un campo son variados pero estáticos, como en asignación de coordenadas a una provincia. Para estos casos tener un diccionario de elementos donde la entrada y el valor estén representados por la clave y el valor respectivamente es una solución muy cómoda.</p>
<p>A la función match_dict se le pasa este diccionario contexto y se encarga de devolver el valor correspondiente de la clave con la que se llama a la función.</p>
</div>
</div>
<div class="section" id="combinando-operaciones-de-campo">
<h3>Combinando operaciones de campo<a class="headerlink" href="#combinando-operaciones-de-campo" title="Permalink to this headline">¶</a></h3>
<p>Toda la arquitectura gira en torno a este concepto, muy potente, de programación funcional que nos permite construir aplicaciones muy complejas con bloques muy sencillos de código (funciones) fáciles de probar y mantener.</p>
<p>La composición se parece mucho a la promación tradicional en que tenemos un conjunto sencillo de operaciones que combinados pueden resolver infinidad de situaciones.
Todas las funciones de la librería se pueden combinar para generar estos comportamientos con la función combine.</p>
<p>Pero este concepto se puede ver mejor con algunos ejemplos.</p>
<div class="section" id="normalizacion-numerica">
<h4>Normalización numérica<a class="headerlink" href="#normalizacion-numerica" title="Permalink to this headline">¶</a></h4>
<p>Convertir un número de entrada en texto a un número y luego llevar a cabo una normalización min max.</p>
</div>
<div class="section" id="fecha-completa">
<h4>Fecha completa<a class="headerlink" href="#fecha-completa" title="Permalink to this headline">¶</a></h4>
<p>Otra operación típica es la de explotar una fecha, querase solo con los años, meses y dias, y añadir un prefijo para evitar colisiones con otros campos.</p>
</div>
<div class="section" id="one-hot-vector-del-dia">
<h4>One hot vector del día<a class="headerlink" href="#one-hot-vector-del-dia" title="Permalink to this headline">¶</a></h4>
<p>Incluso podemos llevar a cabo una transformación mucho más atrevida, como construir un one hot vector, desde una fecha en texto, con el día de la semana.</p>
</div>
</div>
</div>
<div class="section" id="operaciones-de-evento">
<h2>Operaciones de evento<a class="headerlink" href="#operaciones-de-evento" title="Permalink to this headline">¶</a></h2>
<p>Pero las funciones de campo no dicen que queremos hacer con el valor transformado; tal vez quiero que el valor se guarde en un campo con el mismo nombre; o a lo mejor quiero que tenga un nombre de campo diferente. En este nivel tenemos las funciones de fila, que funcionan de forma ligeramente diferente, ya que reciben el input, el output acumulado hasta este momento y el error acumulado hasta este momento; y se espera que devuelvan lo mismo, es decir, input, output y error.</p>
<p>Esto les da el control total en cada paso de la transformación de lo que está pasando, por lo que tienen una gran responsabilidad; es recomendable usar las existentes, aunque se pueden definir nuevas como veremos más adelante.</p>
<div class="section" id="id1">
<h3>Listado de funciones<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="keep-mantener-campos">
<h4>Keep - Mantener campos<a class="headerlink" href="#keep-mantener-campos" title="Permalink to this headline">¶</a></h4>
<p>La operación más sencilla, que no requiere de ninguna función de campo, es Keep. Básicamente coge un campo del input y lo pone en el output sin modificar su valor:</p>
<p>Existe una versión de esta función que funciona exactamente igual pero que recibe una expresión regular como selector de campos. Se llama keep_regexp.</p>
</div>
<div class="section" id="substitution-substituir-campos">
<h4>Substitution - Substituir campos<a class="headerlink" href="#substitution-substituir-campos" title="Permalink to this headline">¶</a></h4>
<p>La siguiente operación si que requiere de una función de campo. Substitution pondrá el campo, con el mismo nombre, en el output pero con el valor transformado por la función de campo que se provea. Por ejemplo, una función to_float que transforme el valor dado en un float podrían usarse así:</p>
</div>
<div class="section" id="append-anadir-nuevos-campos-a-partir-de-uno">
<h4>Append - Añadir nuevos campos a partir de uno<a class="headerlink" href="#append-anadir-nuevos-campos-a-partir-de-uno" title="Permalink to this headline">¶</a></h4>
<p>En muchas ocasiones queremos añadir varios campos con una sola operación, o cambiar el nombre del campo. La operación append permite hacer esto, pero requiere que la función de campo devuelva un diccionario donde el nombre del campo será extraído de la clave del diccionario y el valor del campo del valor del diccionario.Supongamos una función de campo, llamada len_cap, que dada una cadena de texto genera los campos len, con la longitud de la cadena, y cap, con la primera letra en mayúsculas.</p>
<p>Cabe destacar que, en este caso, en el output no está el campo nombre. Esto es así porque aunque se pase a la función el nombre, esta no devuelve en ningún momento el campo nombre, solo len y cap.</p>
</div>
<div class="section" id="fusion-combinar-campos">
<h4>Fusion - Combinar campos<a class="headerlink" href="#fusion-combinar-campos" title="Permalink to this headline">¶</a></h4>
<p>Si nos fijamos con atención veremos que como patrón subyacente estamos llevando a cabo una operación que genera varios campos a partir de uno. Pero es posible que necesitemos la operación opuesta, es decir, a partir de varios campos el generar uno nuevo.</p>
<p>Esta es una de las operaciones más complejas, y se llama fusion; para ilustrar esta función vamos a cambiar el ejemplo. Dada una función de campo suma, que suma todos los valores que recibe, vamos a generar un campo total.</p>
<p>Pero fusión también puede usarse para operaciones más complejas. Supongamos que dependiendo del valor de un campo moneda queremos aplicar un tipo de cambio concreto. Para poder llevar a cabo esta operación necesitamos saber el valor concreto del campo moneda y el campo concreto con la cantidad monetaria. Para poder llevar a cabo esto, debemos saber que, la fusión entrega a la función de transformación de campo una lista, con los parámetros ordenados, exactamente en el mismo orden en el que se especificaron, en la llamada a la operación de fusión. En el ejemplo anterior llamamos a fusión con los campos ene, feb y mar; por lo que el listado que se pasará a la función contendrá los valores 5, 15 y 18.</p>
<p>Con este conocimiento podríamos generar una función que recupere los valores por su orden y que llame a la función de cambio de divisa existente (to_eur).</p>
<p>Y usarla junto con fusión para crear el campo val_eur.</p>
<p>Con este mismo ejemplo se puede intuir la siguiente funcionalidad, fusion_append.</p>
</div>
<div class="section" id="fusion-append-varios-entran-varios-salen">
<h4>Fusion_append - Varios entran, varios salen<a class="headerlink" href="#fusion-append-varios-entran-varios-salen" title="Permalink to this headline">¶</a></h4>
<p>Básicamente es una operación en la que usamos varios campos para generar varios campos. La función de columna recibirá la lista de campos ordenados al igual que en el caso de un fusion. Pero en esta ocasión se espera que devuelva un diccionario con los mismos parametros que en la operación de fusión.</p>
<p>Modificando la función del ejemplo anterior podemos devolver varios campos para no perder los datos originales en una sola operación:</p>
</div>
<div class="section" id="filter-tuple-solo-filas-vip">
<h4>Filter_tuple - Sólo filas vip<a class="headerlink" href="#filter-tuple-solo-filas-vip" title="Permalink to this headline">¶</a></h4>
<p>En algunos casos estamos trabajando con un dataset del que solo queremos una parte. En este caso podemos usar la opración filter_tuple que nos permite descartar las filas que no cumplen una función concreta.</p>
<p>Por ejemplo, si necesitamos descartar las filas que no tengan un campo nulo; primero necesitamos una función que devuelve true si la fila no es nula. Usandola en filter_tuple quedaría algo así.</p>
<p>Cuando la función no devuelve un output, pero tampoco un error es porque la esa fila se ha descartado.</p>
</div>
<div class="section" id="alternative-plan-b">
<h4>Alternative - Plan B<a class="headerlink" href="#alternative-plan-b" title="Permalink to this headline">¶</a></h4>
<p>En muchas ocasiones una operación en concreto no se puede llevar a cabo. Pero sabemos que otra operación puede salver el día. En este caso queremos darle al ETL una operación alternativa.</p>
<p>Supongamos que queremos multiplicar el campo valor por dos, pero si no viene nos vale con poner un 0.</p>
<p>La alternativa se usa cuando la primera opción da un error. Si da un error, por supuesto, ningún cambio que se haya llevado a cabo llegará al output.</p>
</div>
<div class="section" id="fallo-con-estilo">
<h4>Fallo con estilo<a class="headerlink" href="#fallo-con-estilo" title="Permalink to this headline">¶</a></h4>
<p>Cuando registramos el fallo, a cualquier nivel, no detenemos el proceso; si escribes tus propias funciones para la librería asegurate de que son resistentes al fallo. Esto nos permite llevar a cabo una operación especial, el recuperarnos de un error. La operación recover lee del error, escribe en el output y si todo va bien borra del error el campo relacionado. En el siguiente ejemplo, el tercer parametro es el input de error de la función y el segundo el output.</p>
</div>
</div>
<div class="section" id="combinando-operaciones-de-evento">
<h3>Combinando operaciones de evento<a class="headerlink" href="#combinando-operaciones-de-evento" title="Permalink to this headline">¶</a></h3>
<p>Una transformación no solo se compone de un cambio. Es decir, no solo nos quedamos con un grupo de campos; o no solo sustituimos los valores de una forma concreta. Normalmente nos quedamos un campos, cambiamos el valor de otro de una forma concreta y de un tercer campo de forma completamente diferente.</p>
<p>A si que necesitamos un interfaz que lo permita. En este caso tenemos <em>Tr</em>. Este objeto envuelve la operación para evento y expone métodos que nos ayudan a expresar como queremos que funcionen los campos.</p>
<p>Especialmente destacan <em>then</em> y <em>apply</em>. Cuando llamamos a <em>then</em> este devuelve un nuevo objeto <em>Tr</em> que contiene una secuencia con las operaciones anteriores y la operación que hemos pasado a la función then.
Una vez que tenemos todas las funciones encadenadas necesitamos una función que nos permita transformar los datos, ya que en este punto tenemos un objeto <em>Tr</em>. Para esto llamamos a la función <em>apply</em>. Esta función devuelve una sola función, generada en ese momento, que engloba todas las operaciones encadenadas, y que además tiene el mismo interfaz que una operación de fila.
Ten en cuenta que en cuanto llamamos a apply perdemos las funciones <em>then</em> y <em>apply</em>.</p>
<p>Si por ejemplo queremos guardar un campo y sustutir el valor de otro con la función x2 (multiplica un valor por dos) podríamos escribir el siguiente código.</p>
<p>Errores comunes a evitar son pasarle los datos a apply, que no hace nada más que devolver la función a usar. O llamar a la función que estamos pasando a la operación (se pasa sin paréntesis).</p>
<p>En este caso estamos llamando a la función, mientras que en realiad la operación espera una referencia a la función y no el resultado de la llamada sin parámetros.</p>
<p>Esto suele pasar porque algunas de las funciones de la libería reciben parámetros (como min_max_normalization) y devuelven la referencia a la función como resultado y otras no (como explode_date) que se usa directamente la referencia.</p>
<div class="section" id="un-bosque-de-posibilidades">
<h4>Un bosque de posibilidades<a class="headerlink" href="#un-bosque-de-posibilidades" title="Permalink to this headline">¶</a></h4>
<p>Al usar un objeto para encapsular las transformaciones, y este objeto ser inmutable, se da el caso de que podemos guardar pasos intermedios en el proceso de transormación de datos, lo cual es especialmente útil cuando tenemos, por ejemplo, datos de entrenamiento y datos de ejecución.</p>
<p>Los datos de entrenamiento suelen ser como los de ejecución pero contienen un campo extra “label” que suele indicar lo que tiene que aprender (o inferir) el modelo de machine learning.</p>
<p>En el siguiente ejemplo la transformación de datos (el objeto Tr) se construye en un módulo especifico de tu aplicación, y se recupera con la función etl(). Luego añadiremos la lógica para el label:</p>
<p>De esta forma si estamos en la fase de entrenamiento la salida contendrá el label necesario sin tener que saber a priori cuales son las transformaciones específicas para ese set de datos.</p>
</div>
<div class="section" id="then-empujando-transformaciones-al-inicio">
<h4>Then - Empujando transformaciones al inicio<a class="headerlink" href="#then-empujando-transformaciones-al-inicio" title="Permalink to this headline">¶</a></h4>
<p>En ocasiones hay datos que nos llegan en formatos que no entendemos, la librería solo maneja diccionarios de python internamente, o tal vez necesitamos hacer una operación al inicio del proceso.</p>
<p>El interfaz de Tr tiene una función para llevar a cabo esta operación: init. Esta pone al principio de la secuencia de transformaciones la función de evento que pongamos.</p>
<p>En el modulo datarefinery.tuple.Formats encontrarás varias operaciones que transforman el input de los formatos más populares a diccionarios de python. Como además esta es una función que se usa mucho para “leer” los datos el interfaz tiene una función <em>reader</em> que no es más que un alias de <em>init</em>.</p>
<p>Hay que tener cuidado si queremos usar init y tenemos guardadas en variables Tr intermedios que queremos diverger. Ya que todos los Tr que divergen tienen en común la misma referencia a la raiz.</p>
<p><strong>TODO: dibujo de raíz de transformaciones</strong></p>
<p>Si llevamos a cabo esta operación:</p>
<p>En este caso tanto step1 como step2 tendrían como primera operación <em>from_json</em>, y es posible que no es esto lo que queramos llevar a cabo. Si queremos que cada una mantenga un origen independiente te sugiero que uses el siguiente código en su lugar:</p>
</div>
<div class="section" id="peek-cata-de-datos">
<h4>Peek - Cata de datos<a class="headerlink" href="#peek-cata-de-datos" title="Permalink to this headline">¶</a></h4>
<p>La función <em>peek</em> permite leer y manipular los datos sin miedo a modificarlos. Es especialmente útil cuando queremos guardar los datos de un paso intermedio sin parar la transformación.</p>
<p>Ten en cuenta que la función no se llama hasta que no se invoca la función de transformación de datos generada mediante <em>apply</em>. Además debes saber que la función se ejecuta sincronamente, es decir, hasta que la función <em>peek</em> no termina de ejecutarse el proceso no continua, pero falle o no, el proceso continuará.</p>
<p>Debido a que se suele llamar para escribir datos los datos en una fuente externa, el método <em>writer</em> de Tr es un alias de <em>peek</em>.</p>
</div>
<div class="section" id="secuencialidad">
<h4>Secuencialidad<a class="headerlink" href="#secuencialidad" title="Permalink to this headline">¶</a></h4>
<p>Cuando se encadenan funciones con then todas ellas pasan en un solo “paso”. Es decir que todas usan el mismo input y escriben en el mismo output. Por lo que si queremos modificar el valor de un campo ya modificado, aunque lo encadenemos con then, pasan a la vez y recibimos el valor de la segunda transformación solamente. Por ejemplo:</p>
<p>Si pensamos secuencialmente esperamos que si se aplica la función x2 dos veces sobre el campo deberíamos obtener 8, pero eso no es así; al aplicarse de forma paralela lo que está pasando en realidad es algo más bien así:</p>
<div class="line-block">
<div class="line">input | value (1º vez) | value(2º vez) |</div>
<div class="line">—– | ————– | ————- |</div>
<div class="line">2     | 4              | 4             |</div>
</div>
<p>Al pasar al mismo tiempo el input es 2 en las dos llamadas a la función. Y además el resultado de la segunda está sobreescribiendo el resultado de la primera.</p>
<p>Si queremos llevar a cabo estas operaciones, y obetener el resultado esperado, la solución optima es usar compose; que nos permite secuenciar las operaciones de campo, como ya hemos visto, en una sola referencia de función, que es lo que espera la función de fila. El código quedaría así:</p>
<p>Hay una otra opción para llevar a cabo esta operación. Dentro de las operaciones podemos usar change, que lleva a cabo una sustitución pero usa el valor del output en lugar del input, y <strong>sobreescribe</strong> el valor del output con el nuevo valor.</p>
<p>Otra opción es el uso de [DSL](##DSL) de bajo nivel que permite configurar una operación de evento tan compleja como queramos.</p>
<p>En el caso de que queramos llevar cabo esta transformación, pero no tengamos acceso a la operación de campo original, podemos usar la operación de evento chain. Que termina con la operación que estamos llevando a cabo en ese momento y pasa el output al input, para que lo usen las siguientes operaciones propagando el error si es necesario, y <strong>descarta el input</strong> anterior.</p>
<p>Por favor, considera su uso la última opción, es una operación <strong>muy peligrosa</strong> ya que se <strong>pierde el input original</strong>. Esto significa que si te quedan operaciones que hacer con los campos originales no podrás hacerla después. Es especialmente destructivo su uso dentro de un módulo donde un usuario de tu código perdería el input irremediablemente.</p>
</div>
</div>
<div class="section" id="dsl">
<h3>DSL<a class="headerlink" href="#dsl" title="Permalink to this headline">¶</a></h3>
<p>El dsl de bajo nivel nos permite crear cualquier operación que se nos pueda imaginar respecto de una fila, pero como siempre todo gran poder conlleva una gran responsabilidad. Queda bajo tu responsabilidad propagar el input, el output modificado (si procede) y el error modificado (si procede).</p>
<p>Su uso es bastante sencillo, básicamente todas las funciones de evento se crear con este DSL, para ejemplificar su uso vamos a ver como está declarado keep:</p>
<p>Como puedes ver es una composición donde especificamos los pasos por cada campo y finalmente reducimos de nuevo a una sola función con compose. Hay también funciones para usar el input, para usar el error… para casi todas las operaciones que se te puedan ocurrir.</p>
<p>En última instancia puedes generarte tu propia función de 0, aunque te recomiendo seguir la filosofía de atomizar lo máximo posible en funciones de código pequeñas; simplemente debes devolver una fucnión que reciba los tres diccionarios que representan el input, el output y el error y los retorne modificados como proceda.</p>
</div>
</div>
<div class="section" id="repaso-con-ejercicios">
<h2>Repaso con ejercicios<a class="headerlink" href="#repaso-con-ejercicios" title="Permalink to this headline">¶</a></h2>
<p>Si quieres hacer algunos ejercicios para practicar, puedes ejecutar el contenedor así:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>docker run -it --rm -p <span class="m">8888</span>:8888 -v <span class="o">[</span>tu ruta del proyecto etl-func<span class="o">]</span>:/home/jovyan/work datarefinery-notebook:latest
</pre></div>
</div>
<p>Desde jupyter, puedes acceder al notebook con ejercicios básicos en /work/docs/notebooks/thebasics.ipynb.</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="dsl.html" class="btn btn-neutral float-right" title="Tuple DSL documentation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="installation.html" class="btn btn-neutral" title="Instalación" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, BBVA-Labs.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1.52',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>